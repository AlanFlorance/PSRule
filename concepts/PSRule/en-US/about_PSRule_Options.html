<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>PSRule_Options </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="PSRule_Options ">
    <meta name="generator" content="docfx 2.43.2.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../../commands/PSRule/en-US/toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="psrule_options">PSRule_Options</h1>

<h2 id="about_psrule_options">about_PSRule_Options</h2>
<h2 id="short-description">SHORT DESCRIPTION</h2>
<p>Describes additional options that can be used during rule execution.</p>
<h2 id="long-description">LONG DESCRIPTION</h2>
<p>PSRule lets you use options when calling cmdlets such as <code>Invoke-PSRule</code> and <code>Test-PSRuleTarget</code> to change how rules are processed.
This topic describes what options are available, when to and how to use them.</p>
<p>The following workspace options are available for use:</p>
<ul>
<li><a href="#executionlanguagemode">Execution.LanguageMode</a></li>
<li><a href="#executioninconclusivewarning">Execution.InconclusiveWarning</a></li>
<li><a href="#executionnotprocessedwarning">Execution.NotProcessedWarning</a></li>
<li><a href="#inputformat">Input.Format</a></li>
<li><a href="#inputobjectpath">Input.ObjectPath</a></li>
<li><a href="#inputtargettype">Input.TargetType</a></li>
<li><a href="#logginglimitdebug">Logging.LimitDebug</a></li>
<li><a href="#logginglimitverbose">Logging.LimitVerbose</a></li>
<li><a href="#loggingrulefail">Logging.RuleFail</a></li>
<li><a href="#loggingrulepass">Logging.RulePass</a></li>
<li><a href="#outputas">Output.As</a></li>
<li><a href="#outputculture">Output.Culture</a></li>
<li><a href="#outputencoding">Output.Encoding</a></li>
<li><a href="#outputformat">Output.Format</a></li>
<li><a href="#outputpath">Output.Path</a></li>
<li><a href="#outputstyle">Output.Style</a></li>
<li><a href="#suppression">Suppression</a></li>
</ul>
<p>Additionally the following baseline options can be included:</p>
<ul>
<li><a href="#bindingfield">Binding.Field</a></li>
<li><a href="#bindingignorecase">Binding.IgnoreCase</a></li>
<li><a href="#bindingnameseparator">Binding.NameSeparator</a></li>
<li><a href="#bindingtargetname">Binding.TargetName</a></li>
<li><a href="#bindingtargettype">Binding.TargetType</a></li>
<li><a href="#bindingusequalifiedname">Binding.UseQualifiedName</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#ruleinclude">Rule.Include</a></li>
<li><a href="#ruleexclude">Rule.Exclude</a></li>
<li><a href="#ruletag">Rule.Tag</a></li>
</ul>
<p>See <a href="about_PSRule_Baseline.html">about_PSRule_Baseline</a> for more information on baseline options.</p>
<p>Options can be used with the following PSRule cmdlets:</p>
<ul>
<li>Get-PSRule</li>
<li>Get-PSRuleBaseline</li>
<li>Get-PSRuleHelp</li>
<li>Invoke-PSRule</li>
<li>Test-PSRuleTarget</li>
</ul>
<p>Each of these cmdlets support:</p>
<ul>
<li>Using the <code>-Option</code> parameter with an object created with the <code>New-PSRuleOption</code> cmdlet. See cmdlet help for syntax and examples.</li>
<li>Using the <code>-Option</code> parameter with a hashtable object.</li>
<li>Using the <code>-Option</code> parameter with a YAML file path.</li>
</ul>
<p>When using a hashtable object <code>@{}</code>, one or more options can be specified as keys using a dotted notation.</p>
<p>For example:</p>
<pre><code class="lang-powershell">$option = @{ 'Output.Format' = 'Yaml' };
Invoke-PSRule -Path . -Option $option;
</code></pre>
<pre><code class="lang-powershell">Invoke-PSRule -Path . -Option @{ 'Output.Format' = 'Yaml' };
</code></pre>
<p>The above example shows how the <code>Output.Format</code> option as a hashtable key can be used.
Continue reading for a full list of options and how each can be used.</p>
<p>Alternatively, options can be stored in a YAML formatted file and loaded from disk.
Storing options as YAML allows different configurations to be loaded in a repeatable way instead of having to create an options object each time.</p>
<p>Options are stored as YAML properties using a lower camel case naming convention, for example:</p>
<pre><code class="lang-yaml">output:
  format: Yaml
</code></pre>
<p>The <code>Set-PSRuleOption</code> cmdlet can be used to set options stored in YAML or the YAML file can be manually edited.</p>
<pre><code class="lang-powershell">Set-PSRuleOption -OutputFormat Yaml;
</code></pre>
<p>By default, PSRule will automatically look for a default YAML options file in the current working directory. Alternatively, you can specify a specific file path.</p>
<p>For example:</p>
<pre><code class="lang-powershell">Invoke-PSRule -Option '.\myconfig.yml';
</code></pre>
<pre><code class="lang-powershell">New-PSRuleOption -Path '.\myconfig.yaml';
</code></pre>
<p>PSRule uses any of the following file names (in order) as the default YAML options file.
If more than one of these files exist, the following order will be used to find the first match.</p>
<ul>
<li><code>ps-rule.yaml</code></li>
<li><code>ps-rule.yml</code></li>
<li><code>psrule.yaml</code></li>
<li><code>psrule.yml</code></li>
</ul>
<p>We recommend only using lowercase characters as shown above.
This is because not all operation systems treat case in the same way.</p>
<h3 id="bindingfield">Binding.Field</h3>
<p>When an object is passed from the pipeline, PSRule automatically extracts fields from object properties.
PSRule provides standard fields such as <code>TargetName</code> and <code>TargetType</code>.
In addition to standard fields, custom fields can be bound.
Custom fields are available to rules and included in output.</p>
<p>PSRule uses the following logic to determine which property should be used for binding:</p>
<ul>
<li>By default PSRule will not extract any custom fields.</li>
<li>If custom fields are configured, PSRule will attempt to bind the field.
<ul>
<li>If <strong>none</strong> of the configured property names exist, the field will be skipped.</li>
<li>If more then one property name is configured, the order they are specified in the configuration determines precedence.
<ul>
<li>i.e. The first configured property name will take precedence over the second property name.</li>
</ul>
</li>
<li>By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the <a href="#bindingignorecase">Binding.IgnoreCase</a> option.</li>
</ul>
</li>
</ul>
<p>Custom field bindings can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the BindingField parameter
$option = New-PSRuleOption -BindingField @{ id = 'ResourceId', 'AlternativeId' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Binding.Field hashtable key
$option = New-PSRuleOption -Option @{ 'Binding.Field' = @{ id = 'ResourceId', 'AlternativeId' } };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the BindingField parameter to set YAML
Set-PSRuleOption -BindingField @{ id = 'ResourceId', 'AlternativeId' };
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the binding/field property
binding:
  field:
    id:
    - ResourceId
    - AlternativeId
</code></pre>
<h3 id="bindingignorecase">Binding.IgnoreCase</h3>
<p>When evaluating an object, PSRule extracts a few key properties from the object to help filter rules and display output results.
The process of extract these key properties is called <em>binding</em>.
The properties that PSRule uses for binding can be customized by providing a order list of alternative properties to use.
See <a href="#bindingtargetname"><code>Binding.TargetName</code></a> and <a href="#bindingtargettype"><code>Binding.TargetType</code></a> for these options.</p>
<ul>
<li>By default, custom property binding finds the first matching property by name regardless of case. i.e. <code>Binding.IgnoreCase</code> is <code>true</code>.</li>
<li>To make custom bindings case sensitive, set the <code>Binding.IgnoreCase</code> option to <code>false</code>.
<ul>
<li>Changing this option will affect custom property bindings for both <em>TargetName</em> and <em>TargetType</em>.</li>
<li>Setting this option has no affect on binding defaults or custom scripts.</li>
</ul>
</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the BindingIgnoreCase parameter
$option = New-PSRuleOption -BindingIgnoreCase $False;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Binding.IgnoreCase hashtable key
$option = New-PSRuleOption -Option @{ 'Binding.IgnoreCase' = $False };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the BindingIgnoreCase parameter to set YAML
Set-PSRuleOption -BindingIgnoreCase $False;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the binding/ignoreCase property
binding:
  ignoreCase: false
</code></pre>
<h3 id="bindingnameseparator">Binding.NameSeparator</h3>
<p>When an object is passed from the pipeline, PSRule assigns the object a <em>TargetName</em>.
<em>TargetName</em> is used in output results to identify one object from another.</p>
<p>In cases where different types of objects share the same <em>TargetName</em>, this may become confusing.
Using a qualified name, prefixes the <em>TargetName</em> with <em>TargetType</em>.
i.e. <em>TargetType/TargetName</em></p>
<p>To use a qualified name, see the <code>Binding.UseQualifiedName</code> option.</p>
<p>By default, PSRule uses <code>/</code> to separate <em>TargetType</em> from <em>TargetName</em>.
This option configures the separator that PSRule uses between the two components.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the BindingNameSeparator parameter
$option = New-PSRuleOption -BindingNameSeparator '::';
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Binding.NameSeparator hashtable key
$option = New-PSRuleOption -Option @{ 'Binding.NameSeparator' = '::' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the BindingNameSeparator parameter to set YAML
Set-PSRuleOption -BindingNameSeparator '::';
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the binding/nameSeparator property
binding:
  nameSeparator: '::'
</code></pre>
<h3 id="bindingtargetname">Binding.TargetName</h3>
<p>When an object is passed from the pipeline, PSRule assigns the object a <em>TargetName</em>.
<em>TargetName</em> is used in output results to identify one object from another.
Many objects could be passed down the pipeline at the same time, so using a <em>TargetName</em> that is meaningful is important.
<em>TargetName</em> is also used for advanced features such as rule suppression.</p>
<p>The value that PSRule uses for <em>TargetName</em> is configurable. PSRule uses the following logic to determine what <em>TargetName</em> should be used:</p>
<ul>
<li>By default PSRule will:
<ul>
<li>Use <code>TargetName</code> or <code>Name</code> properties on the object. These property names are case insensitive.</li>
<li>If both <code>TargetName</code> and <code>Name</code> properties exist, <code>TargetName</code> will take precedence over <code>Name</code>.</li>
<li>If neither <code>TargetName</code> or <code>Name</code> properties exist, a SHA1 hash of the object will be used as <em>TargetName</em>.</li>
</ul>
</li>
<li>If custom <em>TargetName</em> binding properties are configured, the property names specified will override the defaults.
<ul>
<li>If <strong>none</strong> of the configured property names exist, PSRule will revert back to <code>TargetName</code> then <code>Name</code>.</li>
<li>If more then one property name is configured, the order they are specified in the configuration determines precedence.
<ul>
<li>i.e. The first configured property name will take precedence over the second property name.</li>
</ul>
</li>
<li>By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the <a href="#bindingignorecase">Binding.IgnoreCase</a> option.</li>
</ul>
</li>
<li>If a custom <em>TargetName</em> binding function is specified, the function will be evaluated first before any other option.
<ul>
<li>If the function returns <code>$Null</code> then custom properties, <code>TargetName</code> and <code>Name</code> properties will be used.</li>
<li>The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available.</li>
<li>Custom binding functions are blocked in constrained language mode is used. See <a href="#executionlanguagemode">language mode</a> for more information.</li>
</ul>
</li>
</ul>
<p>Custom property names to use for binding can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the TargetName parameter
$option = New-PSRuleOption -TargetName 'ResourceName', 'AlternateName';
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Binding.TargetName hashtable key
$option = New-PSRuleOption -Option @{ 'Binding.TargetName' = 'ResourceName', 'AlternateName' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the TargetName parameter to set YAML
Set-PSRuleOption -TargetName 'ResourceName', 'AlternateName';
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the binding/targetName property
binding:
  targetName:
  - ResourceName
  - AlternateName
</code></pre>
<p>To specify a custom binding function use:</p>
<pre><code class="lang-powershell"># Create a custom function that returns a TargetName string
$bindFn = {
    param ($TargetObject)

    $otherName = $TargetObject.PSObject.Properties['OtherName'];
    if ($Null -eq $otherName) { return $Null }
    return $otherName.Value;
}

# Specify the binding function script block code to execute
$option = New-PSRuleOption -BindTargetName $bindFn;
</code></pre>
<h3 id="bindingtargettype">Binding.TargetType</h3>
<p>When an object is passed from the pipeline, PSRule assigns the object a <em>TargetType</em>.
<em>TargetType</em> is used to filter rules based on object type and appears in output results.</p>
<p>The value that PSRule uses for <em>TargetType</em> is configurable.
PSRule uses the following logic to determine what <em>TargetType</em> should be used:</p>
<ul>
<li>By default PSRule will:
<ul>
<li>Use the default type presented by PowerShell from <code>TypeNames</code>. i.e. <code>.PSObject.TypeNames[0]</code></li>
</ul>
</li>
<li>If custom <em>TargetType</em> binding properties are configured, the property names specified will override the defaults.
<ul>
<li>If <strong>none</strong> of the configured property names exist, PSRule will revert back to the type presented by PowerShell.</li>
<li>If more then one property name is configured, the order they are specified in the configuration determines precedence.
<ul>
<li>i.e. The first configured property name will take precedence over the second property name.</li>
</ul>
</li>
<li>By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the <a href="#bindingignorecase"><code>Binding.IgnoreCase</code></a> option.</li>
</ul>
</li>
<li>If a custom <em>TargetType</em> binding function is specified, the function will be evaluated first before any other option.
<ul>
<li>If the function returns <code>$Null</code> then custom properties, or the type presented by PowerShell will be used in order instead.</li>
<li>The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available.</li>
<li>Custom binding functions are blocked in constrained language mode is used. See <a href="#executionlanguagemode">language mode</a> for more information.</li>
</ul>
</li>
</ul>
<p>Custom property names to use for binding can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the TargetType parameter
$option = New-PSRuleOption -TargetType 'ResourceType', 'kind';
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Binding.TargetType hashtable key
$option = New-PSRuleOption -Option @{ 'Binding.TargetType' = 'ResourceType', 'kind' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the TargetType parameter to set YAML
Set-PSRuleOption -TargetType 'ResourceType', 'kind';
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the binding/targetType property
binding:
  targetType:
  - ResourceType
  - kind
</code></pre>
<p>To specify a custom binding function use:</p>
<pre><code class="lang-powershell"># Create a custom function that returns a TargetType string
$bindFn = {
    param ($TargetObject)

    $otherType = $TargetObject.PSObject.Properties['OtherType'];

    if ($otherType -eq $Null) {
        return $Null
    }

    return $otherType.Value;
}

# Specify the binding function script block code to execute
$option = New-PSRuleOption -BindTargetType $bindFn;
</code></pre>
<h3 id="bindingusequalifiedname">Binding.UseQualifiedName</h3>
<p>When an object is passed from the pipeline, PSRule assigns the object a <em>TargetName</em>.
<em>TargetName</em> is used in output results to identify one object from another.</p>
<p>In cases where different types of objects share the same <em>TargetName</em>, this may become confusing.
Using a qualified name, prefixes the <em>TargetName</em> with <em>TargetType</em>.
i.e. <em>TargetType/TargetName</em></p>
<p>This option determines if PSRule uses qualified or unqualified names (default).</p>
<p>By default, PSRule uses <code>/</code> to separate <em>TargetType</em> from <em>TargetName</em>.
Set <code>Binding.NameSeparator</code> to change.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the BindingUseQualifiedName parameter
$option = New-PSRuleOption -BindingUseQualifiedName $True;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Binding.UseQualifiedName hashtable key
$option = New-PSRuleOption -Option @{ 'Binding.UseQualifiedName' = $True };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the BindingUseQualifiedName parameter to set YAML
Set-PSRuleOption -BindingUseQualifiedName $True;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the binding/useQualifiedName property
binding:
  useQualifiedName: true
</code></pre>
<h3 id="configuration">Configuration</h3>
<p>Configures a set of baseline configuration values that can be used in rule definitions instead of using hard coded values.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the BaselineConfiguration option with a hashtable
$option = New-PSRuleOption -BaselineConfiguration @{ appServiceMinInstanceCount = 2 };
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the configuration property
configuration:
  appServiceMinInstanceCount: 2
</code></pre>
<h3 id="executionlanguagemode">Execution.LanguageMode</h3>
<p>Unless PowerShell has been constrained, full language features of PowerShell are available to use within rule definitions.
In locked down environments, a reduced set of language features may be desired.</p>
<p>When PSRule is executed in an environment configured for Device Guard, only constrained language features are available.</p>
<p>The following language modes are available for use in PSRule:</p>
<ul>
<li>FullLanguage</li>
<li>ConstrainedLanguage</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the Execution.LanguageMode hashtable key
$option = New-PSRuleOption -Option @{ 'Execution.LanguageMode' = 'ConstrainedLanguage' };
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the execution/languageMode property
execution:
  languageMode: ConstrainedLanguage
</code></pre>
<h3 id="executioninconclusivewarning">Execution.InconclusiveWarning</h3>
<p>When defining rules, it is possible not return a valid <code>$True</code> or <code>$False</code> result within the definition script block.</p>
<p>Rule authors should not intentionally avoid returning a result, however a possible cause for not returning a result may be a rule logic error.</p>
<p>If a rule should not be evaluated, use pre-conditions to avoid processing the rule for objects where the rule is not applicable.</p>
<p>In cases where the rule does not return a result it is marked as inconclusive.</p>
<p>Inconclusive results will:</p>
<ul>
<li>Generate a warning by default.</li>
<li>Fail the object. Outcome will be reported as <code>Fail</code> with an OutcomeReason of <code>Inconclusive</code>.</li>
</ul>
<p>The inconclusive warning can be disabled by using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the InconclusiveWarning parameter
$option = New-PSRuleOption -InconclusiveWarning $False;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Execution.InconclusiveWarning hashtable key
$option = New-PSRuleOption -Option @{ 'Execution.InconclusiveWarning' = $False };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the InconclusiveWarning parameter to set YAML
Set-PSRuleOption -InconclusiveWarning $False;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the execution/inconclusiveWarning property
execution:
  inconclusiveWarning: false
</code></pre>
<h3 id="executionnotprocessedwarning">Execution.NotProcessedWarning</h3>
<p>When evaluating rules, it is possible to incorrectly select a path with rules that use pre-conditions that do not accept the pipeline object.
In this case the object has not been processed by any rule.</p>
<p>Not processed objects will:</p>
<ul>
<li>Generate a warning by default.</li>
<li>Pass the object. Outcome will be reported as <code>None</code>.</li>
</ul>
<p>The not processed warning can be disabled by using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the NotProcessedWarning parameter
$option = New-PSRuleOption -NotProcessedWarning $False;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Execution.NotProcessedWarning hashtable key
$option = New-PSRuleOption -Option @{ 'Execution.NotProcessedWarning' = $False };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the NotProcessedWarning parameter to set YAML
Set-PSRuleOption -NotProcessedWarning $False;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the execution/notProcessedWarning property
execution:
  notProcessedWarning: false
</code></pre>
<h3 id="inputformat">Input.Format</h3>
<p>Configures the input format for when a string is passed in as a target object.</p>
<p>Use this option with <code>Assert-PSRule</code>, <code>Invoke-PSRule</code> or <code>Test-PSRuleTarget</code>.</p>
<p>When the <code>-InputObject</code> parameter or pipeline input is used, strings are treated as plain text by default.
Set this option to either <code>Yaml</code>, <code>Json</code>, <code>Markdown</code>, <code>PowerShellData</code> to have PSRule deserialize the object.</p>
<p>The <code>-Format</code> parameter will override any value set in configuration.</p>
<p>The following formats are available:</p>
<ul>
<li>None - Treat strings as plain text.</li>
<li>Yaml - Treat strings as one or more YAML objects.</li>
<li>Json - Treat strings as one or more JSON objects.</li>
<li>Markdown - Treat strings as a markdown object.</li>
<li>PowerShellData - Treat strings as a PowerShell data object.</li>
<li>Detect - Detect format based on file extension. This is the default.</li>
</ul>
<p>When the <code>-InputPath</code> parameter is used with a file path or URL.
If the <code>Detect</code> format is used, the file extension will be used to automatically detect the format.
When <code>-InputPath</code> is not used, <code>Detect</code> is the same as <code>None</code>.</p>
<p>Detect uses matches the following file extensions:</p>
<ul>
<li>Yaml - <code>.yaml</code> or <code>.yml</code></li>
<li>Json - <code>.json</code></li>
<li>Markdown - <code>.md</code></li>
<li>PowerShellData - <code>.psd1</code></li>
</ul>
<p>The <code>Markdown</code> format does not parse the whole markdown document.
Specifically this format deserializes YAML front matter from the top of the document if any exists.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the Format parameter
$option = New-PSRuleOption -Format Yaml;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Input.Format hashtable key
$option = New-PSRuleOption -Option @{ 'Input.Format' = 'Yaml' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Format parameter to set YAML
Set-PSRuleOption -Format Yaml;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the input/format property
input:
  format: Yaml
</code></pre>
<h3 id="inputobjectpath">Input.ObjectPath</h3>
<p>The object path to a property to use instead of the pipeline object.</p>
<p>By default, PSRule processes objects passed from the pipeline against selected rules.
When this option is set, instead of evaluating the pipeline object, PSRule looks for a property of the pipeline object specified by <code>ObjectPath</code> and uses that instead.
If the property specified by <code>ObjectPath</code> is a collection/ array, then each item is evaluated separately.</p>
<p>If the property specified by <code>ObjectPath</code> does not exist, PSRule skips the object.</p>
<p>When using <code>Invoke-PSRule</code>, <code>Test-PSRuleTarget</code> and <code>Assert-PSRule</code> the <code>-ObjectPath</code> parameter will override any value set in configuration.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the ObjectPath parameter
$option = New-PSRuleOption -ObjectPath 'items';
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Input.ObjectPath hashtable key
$option = New-PSRuleOption -Option @{ 'Input.ObjectPath' = 'items' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the ObjectPath parameter to set YAML
Set-PSRuleOption -ObjectPath 'items';
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the input/objectPath property
input:
  objectPath: items
</code></pre>
<h3 id="inputtargettype">Input.TargetType</h3>
<p>Filters input objects by TargetType.</p>
<p>If specified, only objects with the specified TargetType are processed.
Objects that do not match TargetType are ignored.
If multiple values are specified, only one TargetType must match. This option is not case-sensitive.</p>
<p>By default, all objects are processed.</p>
<p>To change the field TargetType is bound to set the <code>Binding.TargetType</code> option.</p>
<p>When using <code>Invoke-PSRule</code>, <code>Test-PSRuleTarget</code> and <code>Assert-PSRule</code> the <code>-TargetType</code> parameter will override any value set in configuration.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the InputTargetType parameter
$option = New-PSRuleOption -InputTargetType 'virtualMachine';
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Input.TargetType hashtable key
$option = New-PSRuleOption -Option @{ 'Input.TargetType' = 'virtualMachine' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the InputTargetType parameter to set YAML
Set-PSRuleOption -InputTargetType 'virtualMachine';
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the input/targetType property
input:
  targetType:
  - virtualMachine
</code></pre>
<h3 id="logginglimitdebug">Logging.LimitDebug</h3>
<p>Limits debug messages to a list of named debug scopes.</p>
<p>When using the <code>-Debug</code> switch or preference variable, by default PSRule cmdlets log all debug output.
When using debug output for debugging a specific rule, it may be helpful to limit debug message to a specific rule.</p>
<p>To identify a rule to include in debug output use the rule name.</p>
<p>The following built-in scopes exist in addition to rule names:</p>
<ul>
<li><code>[Discovery.Source]</code> - Discovery messages for <code>.Rule.ps1</code> files and rule modules.</li>
<li><code>[Discovery.Rule]</code> - Discovery messages for individual rules within <code>.Rule.ps1</code> files.</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the LoggingLimitDebug parameter
$option = New-PSRuleOption -LoggingLimitDebug Rule1, Rule2;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Logging.LimitDebug hashtable key
$option = New-PSRuleOption -Option @{ 'Logging.LimitDebug' = Rule1, Rule2 };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the LoggingLimitDebug parameter to set YAML
Set-PSRuleOption -LoggingLimitDebug Rule1, Rule2;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the logging/limitDebug property
logging:
  limitDebug:
  - Rule1
  - Rule2
</code></pre>
<h3 id="logginglimitverbose">Logging.LimitVerbose</h3>
<p>Limits verbose messages to a list of named verbose scopes.</p>
<p>When using the <code>-Verbose</code> switch or preference variable, by default PSRule cmdlets log all verbose output.
When using verbose output for troubleshooting a specific rule, it may be helpful to limit verbose messages to a specific rule.</p>
<p>To identify a rule to include in verbose output use the rule name.</p>
<p>The following built-in scopes exist in addition to rule names:</p>
<ul>
<li><code>[Discovery.Source]</code> - Discovery messages for <code>.Rule.ps1</code> files and rule modules.</li>
<li><code>[Discovery.Rule]</code> - Discovery messages for individual rules within <code>.Rule.ps1</code> files.</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the LoggingLimitVerbose parameter
$option = New-PSRuleOption -LoggingLimitVerbose Rule1, Rule2;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Logging.LimitVerbose hashtable key
$option = New-PSRuleOption -Option @{ 'Logging.LimitVerbose' = Rule1, Rule2 };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the LoggingLimitVerbose parameter to set YAML
Set-PSRuleOption -LoggingLimitVerbose Rule1, Rule2;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the logging/limitVerbose property
logging:
  limitVerbose:
  - Rule1
  - Rule2
</code></pre>
<h3 id="loggingrulefail">Logging.RuleFail</h3>
<p>When an object fails a rule condition the results are written to output as a structured object marked with the outcome of <em>Fail</em>.
If the rule executed successfully regardless of outcome no other informational messages are shown by default.</p>
<p>In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages or abort the CI process if one or more <em>Fail</em> outcomes are returned.</p>
<p>By settings this option, error, warning or information messages will be generated for each rule <em>fail</em> outcome in addition to structured output.
By default, outcomes are not logged to an informational stream (i.e. None).</p>
<p>The following streams available:</p>
<ul>
<li>None</li>
<li>Error</li>
<li>Warning</li>
<li>Information</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the LoggingRuleFail parameter
$option = New-PSRuleOption -LoggingRuleFail Error;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Logging.RuleFail hashtable key
$option = New-PSRuleOption -Option @{ 'Logging.RuleFail' = 'Error' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the LoggingRuleFail parameter to set YAML
Set-PSRuleOption -LoggingRuleFail Error;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the logging/ruleFail property
logging:
  ruleFail: Error
</code></pre>
<h3 id="loggingrulepass">Logging.RulePass</h3>
<p>When an object passes a rule condition the results are written to output as a structured object marked with the outcome of <em>Pass</em>.
If the rule executed successfully regardless of outcome no other informational messages are shown by default.</p>
<p>In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages.</p>
<p>By settings this option, error, warning or information messages will be generated for each rule <em>pass</em> outcome in addition to structured output.
By default, outcomes are not logged to an informational stream (i.e. None).</p>
<p>The following streams available:</p>
<ul>
<li>None</li>
<li>Error</li>
<li>Warning</li>
<li>Information</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the LoggingRulePass parameter
$option = New-PSRuleOption -LoggingRulePass Information;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Logging.RulePass hashtable key
$option = New-PSRuleOption -Option @{ 'Logging.RulePass' = 'Information' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the LoggingRulePass parameter to set YAML
Set-PSRuleOption -LoggingRulePass Information;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the logging/rulePass property
logging:
  rulePass: Information
</code></pre>
<h3 id="outputas">Output.As</h3>
<p>Configures the type of results to produce.</p>
<p>This option only applies to <code>Invoke-PSRule</code>.
<code>Invoke-PSRule</code> also include a <code>-As</code> parameter to set this option at runtime.
If specified, the <code>-As</code> parameter take precedence, over this option.</p>
<p>The following options are available:</p>
<ul>
<li>Detail - Return a record per rule per object.</li>
<li>Summary - Return summary information for per rule.</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the OutputAs parameter
$option = New-PSRuleOption -OutputAs Yaml;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Output.As hashtable key
$option = New-PSRuleOption -Option @{ 'Output.As' = 'Summary' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the OutputAs parameter to set YAML
Set-PSRuleOption -OutputAs Yaml;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the output/as property
output:
  as: Summary
</code></pre>
<h3 id="outputculture">Output.Culture</h3>
<p>Specified the name of one or more cultures to use for generating output.
When multiple cultures are specified, the first matching culture will be used.
If a culture is not specified, PSRule will use the current PowerShell culture.</p>
<p>PSRule cmdlets also include a <code>-Culture</code> parameter to set this option at runtime.
If specified, the <code>-Culture</code> parameter take precedence, over this option.</p>
<p>To get a list of cultures use the <code>Get-Culture -ListAvailable</code> cmdlet.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the OutputCulture parameter
$option = New-PSRuleOption -OutputCulture 'en-AU';
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Output.Culture hashtable key
$option = New-PSRuleOption -Option @{ 'Output.Culture' = 'en-AU' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the OutputCulture parameter to set YAML
Set-PSRuleOption -OutputCulture 'en-AU', 'en-US';
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the output/culture property
output:
  culture: [ 'en-AU', 'en-US' ]
</code></pre>
<h3 id="outputencoding">Output.Encoding</h3>
<p>Configures the encoding used when output is written to file.
This option has no affect when <code>Output.Path</code> is not set.</p>
<p>The following encoding options are available:</p>
<ul>
<li>Default</li>
<li>UTF-8</li>
<li>UTF-7</li>
<li>Unicode</li>
<li>UTF-32</li>
<li>ASCII</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the OutputEncoding parameter
$option = New-PSRuleOption -OutputEncoding UTF8;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Output.Format hashtable key
$option = New-PSRuleOption -Option @{ 'Output.Encoding' = 'UTF8' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the OutputEncoding parameter to set YAML
Set-PSRuleOption -OutputEncoding UTF8;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the output/encoding property
output:
  encoding: UTF8
</code></pre>
<h3 id="outputformat">Output.Format</h3>
<p>Configures the format that results will be presented in.
This option applies to <code>Invoke-PSRule</code>, <code>Assert-PSRule</code> and <code>Get-PSRule</code>.
This options is ignored by other cmdlets.</p>
<p>The following format options are available:</p>
<ul>
<li>None - Output is presented as an object using PowerShell defaults. This is the default.</li>
<li>Yaml - Output is serialized as YAML.</li>
<li>Json - Output is serialized as JSON.</li>
<li>NUnit3 - Output is serialized as NUnit3 (XML).</li>
<li>Csv - Output is serialized as a comma separated values (CSV).
<ul>
<li>The following columns are included:
<ul>
<li>RuleName</li>
<li>TargetName</li>
<li>TargetType</li>
<li>Outcome</li>
<li>OutcomeReason</li>
<li>Synopsis</li>
<li>Recommendation</li>
</ul>
</li>
</ul>
</li>
<li>Wide -  Output is presented using the wide table format, which includes reason and wraps columns.</li>
</ul>
<p>The Wide format is ignored by <code>Assert-PSRule</code>. <code>Get-PSRule</code> only accepts <code>Wide</code> or <code>None</code>.
Usage of other formats are treated as <code>None</code>.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the OutputFormat parameter
$option = New-PSRuleOption -OutputFormat Yaml;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Output.Format hashtable key
$option = New-PSRuleOption -Option @{ 'Output.Format' = 'Yaml' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the OutputFormat parameter to set YAML
Set-PSRuleOption -OutputFormat Yaml;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the output/format property
output:
  format: Yaml
</code></pre>
<h3 id="outputpath">Output.Path</h3>
<p>Specifies the output file path to write results.
Directories along the file path will automatically be created if they do not exist.</p>
<p>This option only applies to <code>Invoke-PSRule</code>.
<code>Invoke-PSRule</code> also includes a parameter <code>-OutputPath</code> to set this option at runtime.
If specified, the <code>-OutputPath</code> parameter take precedence, over this option.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the OutputPath parameter
$option = New-PSRuleOption -OutputPath 'out/results.yaml';
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Output.Path hashtable key
$option = New-PSRuleOption -Option @{ 'Output.Path' = 'out/results.yaml' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the OutputPath parameter to set YAML
Set-PSRuleOption -OutputPath 'out/results.yaml';
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the output/path property
output:
  path: 'out/results.yaml'
</code></pre>
<h3 id="outputstyle">Output.Style</h3>
<p>Configures the style that results will be presented in.</p>
<p>This option only applies to output generated from <code>Assert-PSRule</code>.
<code>Assert-PSRule</code> also include a parameter <code>-Style</code> to set this option at runtime.
If specified, the <code>-Style</code> parameter takes precedence, over this option.</p>
<p>The following styles are available:</p>
<ul>
<li>Client - Output is written to the host directly in green/ red to indicate outcome. This is the default.</li>
<li>Plain - Output is written as an unformatted string. This option can be redirected to a file.</li>
<li>AzurePipelines - Output is written with commands that can be interpreted by Azure Pipelines.</li>
<li>GitHubActions - Output is written with commands that can be interpreted by GitHub Actions.</li>
</ul>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the OutputStyle parameter
$option = New-PSRuleOption -OutputStyle AzurePipelines;
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the Output.Style hashtable key
$option = New-PSRuleOption -Option @{ 'Output.Style' = 'AzurePipelines' };
</code></pre>
<pre><code class="lang-powershell"># PowerShell: Using the OutputStyle parameter to set YAML
Set-PSRuleOption -OutputFormat AzurePipelines;
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the output/style property
output:
  style: AzurePipelines
</code></pre>
<h3 id="ruleinclude">Rule.Include</h3>
<p>The name of specific rules to evaluate.
If this option is not specified all rules in search paths will be evaluated.</p>
<p>This option can be overridden at runtime by using the <code>-Name</code> cmdlet parameter.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the Rule.Include hashtable key
$option = New-PSRuleOption -Option @{ 'Rule.Include' = 'Rule1','Rule2' };
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the rule/include property
rule:
  include:
  - rule1
  - rule2
</code></pre>
<h3 id="ruleexclude">Rule.Exclude</h3>
<p>The name of specific rules to exclude from being evaluated.
This will exclude rules specified by <code>Rule.Include</code> or discovered from a search path.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the Rule.Exclude hashtable key
$option = New-PSRuleOption -Option @{ 'Rule.Exclude' = 'Rule3','Rule4' };
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the rule/exclude property
rule:
  exclude:
  - rule3
  - rule4
</code></pre>
<h3 id="ruletag">Rule.Tag</h3>
<p>A set of required key value pairs (tags) that rules must have applied to them to be included.</p>
<p>Multiple values can be specified for the same tag.
When multiple values are used, only one must match.</p>
<p>This option can be overridden at runtime by using the <code>-Tag</code> cmdlet parameter.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the Rule.Tag hashtable key
$option = New-PSRuleOption -Option @{ 'Rule.Tag' = @{ severity = 'Critical','Warning' } };
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the rule/tag property
rule:
  tag:
    severity: Critical
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the rule/tag property, with multiple values
rule:
  tag:
    severity:
    - Critical
    - Warning
</code></pre>
<p>In the example above, rules must have a tag of <code>severity</code> set to either <code>Critical</code> or <code>Warning</code> to be included.</p>
<h3 id="suppression">Suppression</h3>
<p>In certain circumstances it may be necessary to exclude or suppress rules from processing objects that are in a known failed state.</p>
<p>PSRule allows objects to be suppressed for a rule by TargetName.
Objects that are suppressed are not processed by the rule at all but will continue to be processed by other rules.</p>
<p>Rule suppression complements pre-filtering and pre-conditions.</p>
<p>This option can be specified using:</p>
<pre><code class="lang-powershell"># PowerShell: Using the SuppressTargetName option with a hashtable
$option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1', 'TestObject3' };
</code></pre>
<pre><code class="lang-yaml"># YAML: Using the suppression property
suppression:
  storageAccounts.UseHttps:
    targetName:
    - TestObject1
    - TestObject3
</code></pre>
<p>In both of the above examples, <code>TestObject1</code> and <code>TestObject3</code> have been suppressed from being processed by a rule named <code>storageAccounts.UseHttps</code>.</p>
<p>When <strong>to</strong> use rule suppression:</p>
<ul>
<li>A temporary exclusion for an object that is in a known failed state.</li>
</ul>
<p>When <strong>not</strong> to use rule suppression:</p>
<ul>
<li>An object should never be processed by any rule. Pre-filter the pipeline instead.</li>
<li>The rule is not applicable because the object is the wrong type. Use pre-conditions on the rule instead.</li>
</ul>
<p>An example of pre-filtering:</p>
<pre><code class="lang-powershell"># Define objects to validate
$items = @();
$items += [PSCustomObject]@{ Name = 'Fridge'; Type = 'Equipment'; Category = 'White goods'; };
$items += [PSCustomObject]@{ Name = 'Apple'; Type = 'Food'; Category = 'Produce'; };
$items += [PSCustomObject]@{ Name = 'Carrot'; Type = 'Food'; Category = 'Produce'; };

# Example of pre-filtering, only food items are sent to Invoke-PSRule
$items | Where-Object { $_.Type -eq 'Food' } | Invoke-PSRule;
</code></pre>
<p>An example of pre-conditions:</p>
<pre><code class="lang-powershell"># A rule with a pre-condition to only process produce
Rule 'isFruit' -If { $TargetObject.Category -eq 'Produce' } {
    # Condition to determine if the object is fruit
    $TargetObject.Name -in 'Apple', 'Orange', 'Pear'
}
</code></pre>
<h2 id="examples">EXAMPLES</h2>
<h3 id="example-psruleyml">Example PSRule.yml</h3>
<pre><code class="lang-yaml">#
# PSRule example configuration
#

# Configure execution options
execution:
  languageMode: ConstrainedLanguage
  inconclusiveWarning: false
  notProcessedWarning: false

# Configures input options
input:
  format: Yaml
  objectPath: items
  targetType:
  - Microsoft.Compute/virtualMachines
  - Microsoft.Network/virtualNetworks

# Configures outcome logging options
logging:
  limitDebug:
  - Rule1
  - Rule2
  limitVerbose:
  - Rule1
  - Rule2
  ruleFail: Error
  rulePass: Information

output:
  as: Summary
  culture:
  - en-US
  encoding: UTF8
  format: Json
  style: GitHubActions

# Configure rule suppression
suppression:
  storageAccounts.UseHttps:
    targetName:
    - TestObject1
    - TestObject3

# Configure baseline options
binding:
  field:
    id:
    - ResourceId
    - AlternativeId
  ignoreCase: false
  nameSeparator: '::'
  targetName:
  - ResourceName
  - AlternateName
  targetType:
  - ResourceType
  - kind
  useQualifiedName: true

configuration:
  appServiceMinInstanceCount: 2

rule:
  include:
  - rule1
  - rule2
  exclude:
  - rule3
  - rule4
  tag:
    severity:
    - Critical
    - Warning
</code></pre>
<h3 id="default-psruleyml">Default PSRule.yml</h3>
<pre><code class="lang-yaml">#
# PSRule defaults
#

# Note: Only properties that differ from the default values need to be specified.

# Configure execution options
execution:
  languageMode: FullLanguage
  inconclusiveWarning: true
  notProcessedWarning: true

# Configures input options
input:
  format: Detect
  objectPath: null
  targetType: [ ]

# Configures outcome logging options
logging:
  limitDebug: [ ]
  limitVerbose: [ ]
  ruleFail: None
  rulePass: None

output:
  as: Detail
  culture: [ ]
  encoding: Default
  format: None
  style: Client

# Configure rule suppression
suppression: { }

# Configure baseline options
binding:
  field: { }
  ignoreCase: true
  nameSeparator: '/'
  targetName:
  - TargetName
  - Name
  targetType:
  - PSObject.TypeNames[0]
  useQualifiedName: false

configuration: { }

rule:
  include: [ ]
  exclude: [ ]
  tag: { }
</code></pre>
<h2 id="note">NOTE</h2>
<p>An online version of this document is available at <a href="https://github.com/Microsoft/PSRule/blob/master/docs/concepts/PSRule/en-US/about_PSRule_Options.md">https://github.com/Microsoft/PSRule/blob/master/docs/concepts/PSRule/en-US/about_PSRule_Options.md</a>.</p>
<h2 id="see-also">SEE ALSO</h2>
<ul>
<li><a href="https://github.com/Microsoft/PSRule/blob/master/docs/commands/PSRule/en-US/Invoke-PSRule.md">Invoke-PSRule</a></li>
<li><a href="https://github.com/Microsoft/PSRule/blob/master/docs/commands/PSRule/en-US/New-PSRuleOption.md">New-PSRuleOption</a></li>
<li><a href="https://github.com/Microsoft/PSRule/blob/master/docs/commands/PSRule/en-US/Set-PSRuleOption.md">Set-PSRuleOption</a></li>
</ul>
<h2 id="keywords">KEYWORDS</h2>
<ul>
<li>Options</li>
<li>PSRule</li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Microsoft/PSRule/blob/master/docs/concepts/PSRule/en-US/about_PSRule_Options.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
